---
---
Redovisning kmom03
=========================

Jag har ingen tidigare erfarenhet att skriva kod som testar annan kod. Jag hade heller inte någon aning om att man ens gjorde såhär så det var helt nytt för mig.

Jag tycker att enhetstestning verkar jätteroligt. Det är också ett smart sätt att få kontroll på ens kod och veta att den fungerar. Man sparar även mycket tid på att enhetstesta än om testar koden för hand som jag gjort tidigare.

White box testing innebär att man har tillgång till koden man testar och man kan se att testfallen exekverar alla delar av koden. Black box testing innebär att man inte ser koden man testar. Grey box testing är en kombination mellan white och black box testing, man har viss tillgång till hur koden ser ut, t.ex. dokumentation över koden samt vilka algoritmer som används. Positiva tester kontrollerar att koden fungerar som man har tänk och att den utför de funktioner som den ska. När man utför negativa tester så framkallar man fel och kontrollerar att den hanterar felet på rätt sätt, t.ex. avslutar med en felkod eller kastar ett exception.

Uppgiften Tärningsspelet 100 var väldigt utmanande och tidskrävande för mig. Uppgiften i sig är inte så komplicerad men det blir svårare när klasser och objekt är inblandat, det blir att man måste tänka lite extra än när man bara skriver allt upp och ned. Jag satte mig först och skrev flödet i spelet samt vilka klasser jag skulle ha, ungefär vad de ska innehålla och hur de ska hänga ihop. När jag hade en liten aning över hur jag skulle göra så började jag med initieringen av spelet där man ska bestämma vem som ska börja. Då använde jag min klass Dice för att slå en tärning och avgöra vem som fick högst. För resten av spelet använde jag fyra klasser, Dice (en tärning), DiceHand (en tärningshand med ett antal tärningar), GameRound (en spelrunda) och Game (själva spelet som knyter samman allt). Game ärver från GameRound, GameRound har ett objekt av en DiceHand och DiceHand har flera objekt av Dice. Datorn fick en egen metod i klassen GameRound för att rulla tärningarna eftersom den behöver göra val om att forstätta eller inte. Jag gjorde att tärningarna rullas en gång och utvärderas om de innehåller en etta, om de inte gör det slumpas en etta eller tvåa fram, om det blir en tvåa sparas poängen men om det blir en etta återupptas proceduren tills en av tärningarna blir en etta eller om det slumpas fram en tvåa. Jag är helt okej nöjd med spelet men UX-delen kan vara bättre. I dagsläget är det otydligt vems tur det är. Det kan även vara tydligare när det blir en etta samt vad datorn gör för val.

Det gick bra att testa spelet och det kändes ganska enkelt att uppnå hög kodtäckning. Jag tycker att jag lyckats ganska bra med att hålla metoderna små så att de är lätta att testa. Det som var svårt var att testa när man rullar tärningarna eftersom de resulterar i slumpmässiga värden. Jag testade de metoderna genom att kontrollera att varje värde som slumpas fram är ett tal mellan ett och sex. `rollComputer()` metoden är dock ganska komplex med många utfall så den testade jag inte.

I det här kursmomentet har jag lärt mig om vad enhetstestning är för något och hur man testar sin kod. Jag har även lärt mig om UML-diagram och hur man skapar dem. I uppgiften för tärningsspelet har jag fått mer övning i hur man kan koppla samman klasser med arv och komposition.
